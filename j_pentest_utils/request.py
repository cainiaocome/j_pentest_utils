#!/usr/bin/env python
# encoding: utf8

"""
universal http request representation format

same as har request representation

spec: http://www.softwareishard.com/blog/har-12-spec/

method: GET, POST

URL:

headers:
[
    {
        "name": "Accept-Encoding",
        "value": "gzip,deflate",
        "comment": ""
    },
    {
        "name": "Accept-Language",
        "value": "en-us,en;q=0.5",
        "comment": ""
    }
]

cookies:
[
    {
        "name": "TestCookie",
        "value": "Cookie Value",
        "path": "/",
        "domain": "www.janodvarko.cz",
        "expires": "2009-07-24T19:20:30.123+02:00",
        "httpOnly": false,
        "secure": false,
        "comment": ""
    }
]

postData is not in specification, but phantomjs's onResourceRequested is a unicode string,
    so be it, if met any other form, transform it.


be careful when reuse headers, remember to remove Content-Length.
"""

import os
import json
import random
import requests
import urlparse
import traceback
import tldextract

class Request(object):

    def __init__(self, d):
        self.d = d # store raw data
        self.method = d['method']
        self.url = d['url']
        self.headers = d.get( 'headers', [] )
        self.cookies = d.get( 'cookies', [] )
        self.postData = d.get( 'postData', '' )

        # my fields
        self.tld = tldextract.extract( self.url ).registered_domain

    def __iter__( self ):
        yield 'method', self.method
        yield 'url', self.url
        yield 'headers', self.headers
        yield 'cookies', self.cookies
        yield 'postData', self.postData

    def _key( self ):
        if self.method.lower() == 'get' or self.method.lower() == 'post':
            u = urlparse.urlparse( self.url )
            q = tuple( urlparse.parse_qs( u.query ).keys() )
            return ( u.netloc, u.path, q )
        else:
            return ( self.method, self.url )
    
    @staticmethod
    def from_mitm_flow( flow ):
        """
            generate Request from mitm flow
        """
        headers = dict( flow['request_headers'] )
        headers = map( lambda key: {'name':key, 'value':headers[key]}, headers.keys() )
        d = {
            'method': flow['method'],
            'url': flow['url'],
            'headers': headers,
            'postData': flow['request_content'],
        }
        return Request( d )

    def __hash__( self ):
        return hash( self._key() )

    def to_sqlmap( self ):
        """
            generate sqlmapapi options
        """
        url = urlparse.urlparse( self.url )
        path = url.path.split( '/' )
        # todo: path injection

        headers = filter( lambda header:header['name'].lower()!='content-length', self.headers )
        headers = '\r\n'.join( map( lambda header:'{}: {}'.format( header['name'], header['value'] ), headers ) )
        options = {
            'level': '5',
            'risk': '1',
            'threads': '3',
            'smart': True,

            'url': self.url,
            'method': self.method,
            'headers': headers,
            'data': self.postData,
        }

        return options
    
    def is_media( self ):
        """
            from path extract extension and guess file type based on that
        """
        media_ext = "flv,mp4,mp4,swf,jpg,jpeg,png,mp4,gif,pdf,rar,zip,avi,mp4,swf,wmi,exe,mpeg,ppt,pptx,doc,docx,xls,xlsx,apk"
        media_ext = filter( None, media_ext.split(',') )
        ext = self.get_ext()
        return ( (ext) and ( ext in media_ext ) )

    def should_sqli( self ):
        media_ext = "js,flv,mp4,mp4,swf,jpg,jpeg,png,mp4,gif,pdf,rar,zip,avi,mp4,swf,wmi,exe,mpeg,ppt,pptx,doc,docx,xls,xlsx,apk"
        media_ext = filter( None, media_ext.split(',') )
        ext = self.get_ext()
        return ( ext not in media_ext )

    def get_ext( self ):
        """
            get extension from url, so this is not reliable
            os.path.splitext is used to extract extension
        """
        path = urlparse.urlparse( self.url ).path
        ext = os.path.splitext(path)[1]
        return ext




