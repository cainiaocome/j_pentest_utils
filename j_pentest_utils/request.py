#!/usr/bin/env python
# encoding: utf8

"""
universal http request representation format

same as har request representation

spec: http://www.softwareishard.com/blog/har-12-spec/

method: GET, POST

URL:

headers:
[
    {
        "name": "Accept-Encoding",
        "value": "gzip,deflate",
        "comment": ""
    },
    {
        "name": "Accept-Language",
        "value": "en-us,en;q=0.5",
        "comment": ""
    }
]

cookies:
[
    {
        "name": "TestCookie",
        "value": "Cookie Value",
        "path": "/",
        "domain": "www.janodvarko.cz",
        "expires": "2009-07-24T19:20:30.123+02:00",
        "httpOnly": false,
        "secure": false,
        "comment": ""
    }
]

postData is not in specification, but phantomjs's onResourceRequested is a unicode string,
    so be it, if met any other form, transform it.


be careful when reuse headers, remember to remove Content-Length.
"""

import os
import json
import random
import requests
import urlparse
import traceback

class Request(object):

    def __init__(self, d):
        self.d = d # store raw data
        self.method = d['method']
        self.url = d['url']
        self.headers = d.get( 'headers', [] )
        self.cookies = d.get( 'cookies', [] )
        self.postData = d.get( 'postData', '' )

    def _key( self ):
        if self.method.lower() == 'get' or self.method.lower() == 'post':
            u = urlparse.urlparse( self.url )
            q = tuple( urlparse.parse_qs( u.query ).keys() )
            return ( u.netloc, u.path, q )
        else:
            return ( self.method, self.url )

    def __hash__( self ):
        return hash( self._key() )

    def to_sqlmap( self ):
        headers = filter( lambda header:header['name'].lower()!='content-length', self.headers )
        headers = '\n'.join( map( lambda header:'{}:{}'.format( header['name'], header['value'] ), headers ) )
        # todo: cookies
        options = {
            'url': self.url,
            'headers': headers,
            'level': '5',
            'risk': '1',
            'threads': '3',
            'smart': True,
        }

    def is_media( self ):
        """
            from path extract extension and guess file type based on that
        """
        media_ext = "flv,mp4,mp4,swf,jpg,jpeg,png,mp4,gif,pdf,rar,zip,avi,mp4,swf,wmi,exe,mpeg,ppt,pptx,doc,docx,xls,xlsx,apk"
        media_ext = filter( None, media_ext.split(',') )
        path = urlparse.urlparse( self.url ).path
        ext = os.path.splitext(path)[1]
        return ext in media_ext





