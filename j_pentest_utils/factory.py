#!/usr/bin/env python3
# encoding: utf8

import os
import sys
import time
import json
import argparse
import traceback
import logging
import queue
import gevent
import multiprocessing
from abc import ABCMeta, abstractmethod

# 如果要使用gevent来做异步io，下面这两行放在脚本开始的地方，不然可能会出现异常，具体看这里：http://www.gevent.org/intro.html
#from gevent import monkey
#monkey.patch_all()

# 请注意multiprocessin和gevent不兼容，要么整个程序只采用gevent，要么只采用multiprocessing和threading来做并发

# 仅仅是import两个模块没有兼容问题，兼容问题出在gevent的monkey patch上面

class BaseFactory( object ):
    """
        paralle tasks using gevent, if task is not cpu intensive, this should be good.
    """
    __metaclass__ = ABCMeta

    def __init__( self, args, max_job_queue_size=4096, autostart=True ):
        self.args = args
        self.job_queue = queue.Queue( max_job_queue_size )
        self.success_queue = queue.Queue( 1024 )
        if autostart:
            self.start()

    def start( self ):
        gevent.spawn( self.manager )
        gevent.spawn( self.success_log )
        for worker_index in range( self.args.thread ):
            gevent.spawn( self.worker )

    @abstractmethod
    def manager(self):
        pass

    def worker(self):
        while True:
            job = self.job_queue.get()
            try:
                t = gevent.spawn( self.do_job, job )
                t.join( job['timeout'] )
                t.get()
            except:
                logging.info( traceback.format_exc() )

    @abstractmethod
    def do_job(self, job):
        pass

    def success_log(self):
        success_txt_fout = open( 'good.txt', 'ab' )
        while True:
            try:
                s = self.success_queue.get()
                success_txt_fout.write( ( json.dumps( s ) + '\n' ).encode('utf8') )
                success_txt_fout.flush()
            except:
                logging.info( traceback.format_exc() )
 
class MultiprocessingFactory( BaseFactory ):
    """
        paralle using multiprocessing
        gevent and multiprocessing can not work together, f**k
    """
    
    def __init__( self, args ):
        self.args = args
        self.job_queue = queue.Queue( 2**20 )
        self.success_queue = multiprocessing.Queue( 1024 )
        gevent.spawn( self.manager )
        gevent.spawn( self.success_log )
        for worker_index in range( self.args.thread ):
            gevent.spawn( self.worker )

    def worker( self ):
        while True:
            job = self.job_queue.get()
            try:
                p = multiprocessing.Process( target=self.do_job, args=[ job, self.success_queue ] )
                p.start()
                t.join( job['timeout'] )
            except:
                pass
    
    @abstractmethod
    def do_job( self, job, success_queue ):
        pass
    
    @abstractmethod
    def manager( self ):
        pass
