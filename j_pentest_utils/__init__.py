#!/usr/bin/env python
# encoding: utf8

import os
import sys
import json
import socket
import threading


from .factory import BaseFactory
from .devnull import get_devnull

def getcert(addr, timeout=None):
    import socket
    import ssl
    """Retrieve server's certificate at the specified address (host, port)."""
    # it is similar to ssl.get_server_certificate() but it returns a dict
    # and it verifies ssl unconditionally, assuming create_default_context does
    sock = socket.create_connection(addr, timeout=timeout)

    context = ssl._create_unverified_context()
    #context = ssl.create_default_context()
    sslsock = context.wrap_socket(sock, server_hostname=addr[0])
    peercert = sslsock.getpeercert()
    sslsock.close()
    sock.close()

    return peercert

def bytes_to_unicode( s, add_encoding=[] ):
    """
        使用常见的编码方式对bytes进行尝试性解码，如果没有异常抛出就算解码正确
        应该没有什么大问题吧 -_-
        如果传入的s已经是unicode形式了就直接返回
    """
    if isinstance( s, str ):
        return s
    for encoding in add_encoding + [ 'ascii', 'utf8', 'gb2312', 'gbk' ]:
        try:
            s_decoded = s.decode( encoding )
            return s_decoded
        except:
            pass
    else:
        raise Exception( '<j_pentest_utils.bytes_to_unicode> all encoding failed' )

def start_thread_as_daemon(target, args):
    t = threading.Thread( target=target, args=args )
    t.daemon = True
    t.start()
    return t

def jsoncsv_read( path ):
    """
        jsoncsv file read and parse
        jsoncsv: one json one line
    """
    with open( path ) as fin:
        lines = fin.read().split('\n')
    lines = list( map( lambda line:json.loads(line.strip()), filter( None, lines ) ) )
    return lines


def textcsv_read( path ):
    """
        one text(str) one line
    """
    with open( path ) as fin:
        lines = fin.read().split('\n')

    lines = list( map( lambda line:line.strip(), filter( None, lines ) ) )
    return lines

def get_one_port():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    for port in range( 1025, 65535 ):
        address = ('0.0.0.0', port)
        try:
            s.bind( address)
            s.close()
            return port
        except:
            pass

if __name__=='__main__':
    print('do not call this directly')
