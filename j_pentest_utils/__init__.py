#!/usr/bin/env python
# encoding: utf8

import os
import sys
import json
import socket
import random
import hashlib
import string
import threading


from .factory import BaseFactory
from .devnull import get_devnull

def getcert(addr, timeout=None):
    import socket
    import ssl
    """Retrieve server's certificate at the specified address (host, port)."""
    # it is similar to ssl.get_server_certificate() but it returns a dict
    # and it verifies ssl unconditionally, assuming create_default_context does
    sock = socket.create_connection(addr, timeout=timeout)

    context = ssl._create_unverified_context()
    #context = ssl.create_default_context()
    sslsock = context.wrap_socket(sock, server_hostname=addr[0])
    peercert = sslsock.getpeercert()
    sslsock.close()
    sock.close()

    return peercert

def bytes_to_unicode( s, add_encoding=[] ):
    """
        使用常见的编码方式对bytes进行尝试性解码，如果没有异常抛出就算解码正确
        应该没有什么大问题吧 -_-
        如果传入的s已经是unicode形式了就直接返回
    """
    if isinstance( s, str ):
        return s
    for encoding in add_encoding + [ 'ascii', 'utf8', 'gb2312', 'gbk' ]:
        try:
            s_decoded = s.decode( encoding )
            return s_decoded
        except:
            pass
    else:
        raise Exception( '<j_pentest_utils.bytes_to_unicode> all encoding failed' )

def start_thread_as_daemon(target, args):
    t = threading.Thread( target=target, args=args )
    t.daemon = True
    t.start()
    return t

def jsoncsv_read( path ):
    """
        jsoncsv file read and parse
        jsoncsv: one json one line
    """
    with open( path ) as fin:
        for line in fin:
            yield json.loads( line.strip() )

def textcsv_read( path ):
    """
        one text(str) one line
    """
    with open( path ) as fin:
        for line in fin:
            yield line.strip()

def get_tcp_port( count=1, interface='0.0.0.0' ):
    def get_one_tcp_port( blacklistports ):
        for port in range( 1025, 65535 ):
            if port in blacklistports:
                continue
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                address = (interface, port)
                s.bind( address )
                s.close()
                return port
            except:
                traceback.print_exc()
    r_ports = []
    for i in range( count ):
        r_ports.append( get_one_tcp_port( r_ports ) )
    return r_ports

def get_one_udp_port():
    s = socket.socket(socket.AF_INET, # Internet
                         socket.SOCK_DGRAM) # UDP
    for port in range( 1025, 65535 ):
        address = ('0.0.0.0', port)
        try:
            s.bind( address )
            s.close()
            return port
        except:
            pass

def randomperm( bits ):
    key = ''.join( random.sample( string.ascii_letters * 8, 8 ) )
    for index in range( 2**bits ):
        half1 = int(bits/2)
        half2 = int((bits+1)/2)
        mask1 = ( 1<< half1 ) -1
        mask2 = ( 1<< half2 ) -1
        for _round in range(5):
            temp = index>>half1
            temp = temp<<4 + _round
            index ^= int( hashlib.sha1( (key+'/'+str(temp)).encode('utf8') ).hexdigest(), 16 ) & mask1
            index = ((index & mask2) << half1) | ((index >> half2) & mask1)
        yield index

if __name__=='__main__':
    print('do not call this directly')
